# -*- coding: utf-8 -*-
"""Module2_Week2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Ci7P_Zgm8b9aHeIs3rhaXJ2oblwBbqn
"""

import numpy as np
def comput_vector_length(vector):
    len_vector = np.sqrt(np.sum(vector**2))
    return len_vector

def comput_dot_product(vector1, vector2):
    for i in range(len(vector1)):
        dot_product = vector1[i]*vector2[i]

def matrix_multi_product(matrix1, matrix2):
    row_matrix1 = len(matrix1)
    colum_matrix1 = len(matrix1[0])
    row_matrix2 = len(matrix2)
    column_matrix2= len(matrix2[0])
    for i in range(row_matrix1):
        for j in range(column_matrix2):
            sum = 0
            for k in range(colum_matrix1):
                sum += matrix1[i][k]*matrix2[k][j]
    return sum

def inverse_matrix(matrix):
    a = matrix[0,0]
    b= matrix [0,1]
    c = matrix[1,0]
    d = matrix[1,1]
    det = a*d-b*c
    inv_a = d/det
    inv_b = -b/det
    inv_c = -c/det
    inv_d = a/det

    inv_matrix = np.array([[inv_a,inv_b],[inv_c,inv_d]])
    return inv_matrix

print(inverse_matrix(np.array([[-2,6],[8,-4]])))

import math

def normalize_vector(v):
    magnitude = math.sqrt(sum([vi**2 for vi in v]))
    return [vi / magnitude for vi in v]

def power_iteration(A, num_simulations: int):
    b_k = [1.0 for _ in range(len(A))]

    for _ in range(num_simulations):
        b_k1 = [sum(A[i][j] * b_k[j] for j in range(len(A))) for i in range(len(A))]

        b_k1_norm = math.sqrt(sum([x**2 for x in b_k1]))
        b_k = [x / b_k1_norm for x in b_k1]

    Av = [sum(A[i][j] * b_k[j] for j in range(len(A))) for i in range(len(A))]
    eigenvalue = sum(b_k[i] * Av[i] for i in range(len(A)))

    return eigenvalue, b_k

# Example matrix
A = [ [0.9, 0.2],
[0.1, 0.8]]

# Finding dominant eigenvalue and eigenvector
eigenvalue, eigenvector = power_iteration(A, 100)

print("Dominant Eigenvalue:", eigenvalue)
print("Corresponding Eigenvector:", eigenvector)
normalized_eigenvector = normalize_vector(eigenvector)
print("Normalized Eigenvector:", normalized_eigenvector)

import math

def cosine_similarity(x, y):
    if len(x) != len(y):
        raise ValueError("Vectors must be the same length")

    dot_product = sum(xi * yi for xi, yi in zip(x, y))

    magnitude_x = math.sqrt(sum(xi**2 for xi in x))

    magnitude_y = math.sqrt(sum(yi**2 for yi in y))

    if magnitude_x == 0 or magnitude_y == 0:
        raise ValueError("One of the vectors is zero vector, cosine similarity is not defined")

    cosine_sim = dot_product / (magnitude_x * magnitude_y)

    return cosine_sim

# Example usage
x = [1, 2, 3, 4]
y = [1, 0,3, 0]

cos_sim = cosine_similarity(x, y)
print("Cosine Similarity:", cos_sim)

"""#Image"""

import numpy as np
from google.colab.patches import cv2_imshow
import cv2

# Đọc và thay đổi kích thước ảnh nền 1
bg1_image = cv2.imread('GreenBackground.png', 1)
bg1_image = cv2.resize(bg1_image, (678, 381))

# Đọc và thay đổi kích thước ảnh đối tượng
ob_image = cv2.imread('Object.png', 1)
ob_image = cv2.resize(ob_image, (678, 381))

# Đọc và thay đổi kích thước ảnh nền 2
bg2_image = cv2.imread('NewBackground.jpg', 1)
bg2_image = cv2.resize(bg2_image, (678, 381))

def compute_difference(bg_img, input_img):
    # Chuyển đổi cả hai ảnh thành ảnh xám
    bg_gray = cv2.cvtColor(bg_img, cv2.COLOR_BGR2GRAY)
    input_gray = cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)

    # Tính sự khác biệt giữa hai ảnh xám
    difference_single_channel = cv2.absdiff(bg_gray, input_gray)

    return difference_single_channel

difference_single_channel = compute_difference (bg1_image, ob_image)
cv2_imshow (difference_single_channel)

def compute_binary_mask(difference_single_channel):
    # Đặt ngưỡng để phân loại pixel thành trắng (255) hoặc đen (0)
    _, difference_binary = cv2.threshold(difference_single_channel, 30, 255, cv2.THRESH_BINARY)

    return difference_binary

# Tính sự khác biệt giữa ảnh nền và ảnh đối tượng
difference_single_channel = compute_difference(bg1_image, ob_image)

# Tạo mặt nạ nhị phân từ sự khác biệt
binary_mask = compute_binary_mask(difference_single_channel)

def replace_background(bg1_image, bg2_image, ob_image):
    difference_single_channel = compute_difference(bg1_image, ob_image)

    binary_mask = compute_binary_mask(difference_single_channel)
    binary_mask_colored = cv2.cvtColor(binary_mask, cv2.COLOR_GRAY2BGR)

    output = np.where(binary_mask_colored == [255, 255, 255], ob_image, bg2_image)

    return output